// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! ## `humility rendmp`
//!
//! `humility rendmp` allows for querying, dumping and flashing the Renesas
//! Digital Multiphase family of voltage regulators.
//!
//! Like `humility pmbus`, a device can be specified in terms of an
//! address (which requires the further specification of a controller and
//! port) or a PMbus rail.
//!
//! To view the number of NVM OTP slots that remain, use the `--slots`
//! option:
//!
//! ```console
//! $ humility rendmp -b mid -d 0x5a --slots
//! humility: attached via ST-Link V3
//! humility: RAA229618 at I2C3, port H, dev 0x5a has 28 slots available
//! ```
//!
//! To determine the OTP CRC, use the `--crc` option.  Note that an
//! entirely unprogrammed part generally has a CRC of 0:
//!
//! ```console
//! $ humility rendmp -b mid -d 0x5a --crc
//! humility: attached via ST-Link V3
//! humility: RAA229618 at I2C3, port H, dev 0x5a has CRC 0x00000000
//! ```
//!
//! To flash a part (that is, to program its one-time programmable
//! non-volatile memory), specify the HEX file as generated by the
//! Renesas PowerNavigator.  Note that this file specifies the address
//! of the device; mismatches are not permitted, e.g.:
//!
//! ```console
//! $ humility rendmp -b mid -d 0x5b --flash ./raa229618-0x5a.hex
//! humility: attached via ST-Link V3
//! humility rendmp failed: image specifies address to be 0x5a; can't flash 0x5b
//! ```
//!
//! Specify the proper device to flash:
//!
//! ```console
//! $ humility rendmp -b mid -d 0x5a --flash ./raa229618-0x5a.hex
//! humility: attached via ST-Link V3
//! humility: 28 NVM slots remain
//! humility: flashing 2871 bytes
//! humiility: flashed 2.80KB in 4 seconds
//! humility: bank 0: bank written successfully
//! humility: flashed successfully after 246 ms; power cycle to load new configuration
//! ```
//!
//! To check a configuration, specify the image and the `--check` option:
//!
//! ```console
//! $ humility rendmp -b mid -d 0x5c -f ./isl68224-0x5c.hex --check
//! humility: attached via ST-Link V3
//! humility: 27 NVM slots remain
//! humility: image CRC (0x841f35a5) matches OTP CRC
//! ```
//!
//! The Renesas voltage regulators include a black box which stores fault
//! information.  This can be queried using the `--blackbox` subcommand,
//! specifying a device (I2C) address to pick a specific power converter:
//!
//! ```console
//! $ humility rendmp --blackbox --device=0x5b
//! humility: attached to 0483:374f:000C001F4D46500F20373033 via ST-Link V3
//! rail0 uptime: 0 sec
//! rail1 uptime: 0 sec
//! controller fault: 0
//! rail0 fault: 00000000000000000000000000000000 ()
//! rail1 fault: 00000000000000000000000000000000 ()
//! phase fault uc: 00000000000000000000000000000000 ()
//! phase fault oc: 00000000000000000000000000000000 ()
//! adc fault uc: 00000000000000000000000000000000 ()
//! adc fault oc: 00000000000000000000000000000000 ()
//! rail0 status: 0000000000000000 ()
//! rail1 status: 0000000000000000 ()
//! status cml: 00000000 ()
//! status mfr: 00000000 ()
//! rail1 status vout: 00000000 ()
//! rail0 status vout: 00000000 ()
//! rail1 status iout: 00000000 ()
//! rail0 status iout: 00000000 ()
//! rail1 status temperature: 00000000 ()
//! rail0 status temperature: 00000000 ()
//! rail1 status input: 00000000 ()
//! rail0 status input: 00000000 ()
//!
//!      | RAIL 0  | RAIL 1
//! -----|---------|-----------
//! VIN  | 0.00 V  | 0.00 V
//! VOUT | 0.000 V | 0.000 V
//! IIN  | 0.00 A  | 0.00 A
//! IOUT | 0.0 A   | 0.0 A
//! TEMP | 0°C     | 0°C
//! controller read temperature: 0°C
//!
//!  PHASE | TEMPERATURE | CURRENT
//! -------|-------------|----------
//!  0     | 0°C         | 0.0 A
//!  1     | 0°C         | 0.0 A
//!  2     | 0°C         | 0.0 A
//!  3     | 0°C         | 0.0 A
//!  4     | 0°C         | 0.0 A
//!  5     | 0°C         | 0.0 A
//!  6     | 0°C         | 0.0 A
//!  7     | 0°C         | 0.0 A
//!  8     | 0°C         | 0.0 A
//!  9     | 0°C         | 0.0 A
//!  10    | 0°C         | 0.0 A
//!  11    | 0°C         | 0.0 A
//!  12    | 0°C         | 0.0 A
//!  13    | 0°C         | 0.0 A
//!  14    | 0°C         | 0.0 A
//!  15    | 0°C         | 0.0 A
//!  16    | 0°C         | 0.0 A
//!  17    | 0°C         | 0.0 A
//!  18    | 0°C         | 0.0 A
//!  19    | 0°C         | 0.0 A
//! ```
//! (In the example above, there have been no faults so the blackbox is empty)
//!
//! To check individual phases for errors, use the `--phase-check` subcommand:
//! ```console
//! $ humility rendmp --phase-check --device=0x5c
//! humility: attached to 0483:3754:000D00344741500820383733 via ST-Link V3
//! Phase check for ISL68221 at 0x5c
//! PHASE |    VOUT    |    IOUT    |    TEMP    | RAIL
//! ------|------------|------------|------------|------------
//!  0    |     0.441V |   -56.100A |   25.000°C | VPP_ABCD
//!  1    |     0.448V |   -55.800A |   26.000°C | VPP_EFGH
//!  2    |     0.453V |     0.900A |    0.000°C | V1P8_SP3
//! ```
//!
//! This must be run with the system in the A2 power state, and on a machine
//! with no DIMMs.  This latter constraint can be overridden with
//! `--force-phase-check`, but this should be used carefully:  if a checked
//! phase powers a DIMM, an I2C hang can result.
//!

use humility::hubris::*;
use humility::reflect::{Base, Value};
use humility::warn;
use humility_cli::{ExecutionContext, Subcommand};
use humility_cmd::{Archive, Attach, Command, CommandKind, Validate};
use humility_hiffy::*;
use humility_i2c::I2cArgs;
use humility_idol::{HubrisIdol, IdolOperation};

use anyhow::{anyhow, bail, Context, Result};
use clap::{CommandFactory, Parser};
use colored::Colorize;
use hif::*;
use indicatif::{HumanBytes, HumanDuration};
use indicatif::{ProgressBar, ProgressStyle};
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;
use std::collections::{BTreeMap, HashMap, HashSet};
use std::fs::{self, OpenOptions};
use std::io::prelude::*;
use std::io::BufReader;
use std::io::Write;
use std::thread;
use std::time::{Duration, Instant};
use zerocopy::{AsBytes, FromBytes};

mod blackbox;

#[derive(Parser, Debug)]
#[clap(name = "rendmp", about = env!("CARGO_PKG_DESCRIPTION"),
    group = clap::ArgGroup::new("subcommand").multiple(false)
)]
struct RendmpArgs {
    /// sets timeout
    #[clap(
        long, short, default_value_t = 5000, value_name = "timeout_ms",
        parse(try_from_str = parse_int::parse)
    )]
    timeout: u32,

    #[clap(flatten)]
    dev: DeviceIdentity,

    /// dump all device memory
    #[clap(long, group = "subcommand")]
    dump: bool,

    /// ingest a Power Navigator text file
    #[clap(long, short, value_name = "filename", group = "subcommand")]
    ingest: Option<String>,

    /// flash a Power Navigator HEX image
    #[clap(long, short, value_name = "filename", group = "subcommand")]
    flash: Option<String>,

    /// display the number of NVM slots remaining
    #[clap(long, short, group = "subcommand")]
    slots: bool,

    /// display the current flash CRC
    #[clap(long, group = "subcommand")]
    crc: bool,

    /// reads the contents of a Renesas power converter black box
    #[clap(long, group = "subcommand")]
    blackbox: bool,

    /// checks for open pins on the given converter
    #[clap(long, group = "subcommand")]
    open_pin: bool,

    /// checks for open pins on the given converter
    #[clap(long, group = "subcommand")]
    phase_check: bool,

    /// only check the specified phase(s)
    #[clap(long, requires = "phase-check", use_value_delimiter = true)]
    phase: Option<Vec<u8>>,

    /// force phase check, even if DIMMs are present
    #[clap(long, requires = "phase-check")]
    force_phase_check: bool,

    // NOTE: the arguments below are only valid when --flash is provided.
    // Unfortunately, due to clap#4707, they are accepted for *any* option in
    // the `subcommand` group; there's a check in code to enforce this
    // constraint manually.
    /// perform dry-run of flash
    #[clap(long = "dry-run", short = 'n', requires = "flash")]
    dryrun: bool,

    /// force flashing, even if the CRCs in the image and OTP match
    #[clap(long, short = 'F', requires = "flash")]
    force: bool,

    /// check the OTP CRC against the image CRC
    #[clap(long, short = 'C', requires = "flash")]
    check: bool,
}

#[derive(Parser, Debug)]
struct DeviceIdentity {
    /// specifies a device by rail name
    #[clap(long, short = 'r', value_name = "rail")]
    rail: Option<String>,

    /// specifies a PMBus driver
    #[clap(long, short = 'D')]
    driver: Option<String>,

    /// specifies an I2C bus by name
    #[clap(long, short, value_name = "bus",
        conflicts_with_all = &["port", "controller"]
    )]
    bus: Option<String>,

    /// specifies an I2C controller
    #[clap(long, short, value_name = "controller",
        parse(try_from_str = parse_int::parse),
    )]
    controller: Option<u8>,

    /// specifies an I2C controller port
    #[clap(long, short, value_name = "port")]
    port: Option<String>,

    /// specifies I2C multiplexer and segment
    #[clap(long, short, value_name = "mux:segment")]
    mux: Option<String>,

    /// specifies an I2C device address
    #[clap(long, short = 'd', value_name = "address")]
    device: Option<String>,
}

#[derive(Copy, Clone, Debug, FromPrimitive)]
enum RendmpGenTwo {
    ISL68220 = 0x63,
    ISL68221 = 0x62,
    ISL68222 = 0x61,
    ISL68223 = 0x53,
    ISL68224 = 0x52,
    ISL68225 = 0x51,
    ISL68226 = 0x50,
    ISL68227 = 0x4F,
    ISL68229 = 0x4E,
    ISL68233 = 0x6B,
    ISL68236 = 0x4D,
    ISL68239 = 0x4B,
    ISL69222 = 0x3E,
    ISL69223 = 0x3D,
    ISL69224 = 0x3C,
    ISL69225 = 0x3B,
    ISL69227 = 0x3A,
    ISL69228 = 0x39,
    ISL69234 = 0x43,
    ISL69236 = 0x42,
    ISL69237 = 0x66,
    ISL69238 = 0x40,
    ISL69239 = 0x41,
    ISL69242 = 0x58,
    ISL69243 = 0x59,
    ISL69247 = 0x48,
    ISL69248 = 0x47,
    ISL69249 = 0x6D,
    ISL69254 = 0x67,
    ISL69255 = 0x38,
    ISL69256 = 0x37,
    ISL69259 = 0x46,
    ISL69260 = 0x6E,
    ISL69267 = 0x57,
    ISL69268 = 0x3F,
    ISL69269 = 0x55,
    RAA228000 = 0x64,
    RAA228004 = 0x65,
    RAA228006 = 0x6C,
    RAA229001 = 0x69,
    RAA229004 = 0x6A,
    RAA229022 = 0x6F,
    RAA229126 = 0x7E,
}

#[derive(Copy, Clone, Debug, FromPrimitive)]
enum RendmpGenTwoFive {
    RAA228218 = 0x73,
    RAA228227 = 0x75,
    RAA228228 = 0x76,
    RAA229618 = 0x99,
}

#[derive(Copy, Clone, Debug)]
enum RendmpDevice {
    RendmpGenTwo(RendmpGenTwo),
    RendmpGenTwoFive(RendmpGenTwoFive),
}

/// Results of the open-pin register
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum PinState {
    /// The phase is disabled, so we ignore its state
    Masked,
    /// There are no issues with this phase
    Good,
    /// The phase is open, which indicates an error
    Open,
}

impl std::fmt::Display for RendmpDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            RendmpDevice::RendmpGenTwo(d) => write!(f, "{:?}", d),
            RendmpDevice::RendmpGenTwoFive(d) => write!(f, "{:?}", d),
        }
    }
}

#[derive(Copy, Clone, Debug, FromPrimitive, PartialEq)]
enum RendmpBankStatus {
    CRCMismatchOTP = 0b1000,
    CRCMismatchRAM = 0b0100,
    Reserved = 0b0010,
    BankWritten = 0b0001,
    BankUnaffected = 0b0000,
}

impl std::fmt::Display for RendmpBankStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                RendmpBankStatus::CRCMismatchOTP => "CRC mismatch with OTP",
                RendmpBankStatus::CRCMismatchRAM => "CRC mismatch with RAM",
                RendmpBankStatus::Reserved => "<reserved>",
                RendmpBankStatus::BankWritten => "bank written successfully",
                RendmpBankStatus::BankUnaffected => "bank unaffected",
            }
        )
    }
}

impl RendmpDevice {
    fn from_id(id: u8) -> Result<Self> {
        let g2 = RendmpGenTwo::from_u8(id);
        let g2p5 = RendmpGenTwoFive::from_u8(id);

        match (g2, g2p5) {
            (Some(d), None) => Ok(RendmpDevice::RendmpGenTwo(d)),
            (None, Some(d)) => Ok(RendmpDevice::RendmpGenTwoFive(d)),
            (Some(d1), Some(d2)) => {
                panic!("id {:x} matches both {:?} and {:?}", id, d1, d2);
            }
            (None, None) => {
                bail!("unknown device id 0x{:x}", id);
            }
        }
    }

    fn from_str(device: &str) -> Result<Self> {
        let search = device.to_uppercase();

        for i in 0..255u8 {
            if let Ok(d) = Self::from_id(i) {
                if search == format!("{}", d) {
                    return Ok(d);
                }
            }
        }

        bail!("{} does not match a Renesas DMP device", device);
    }

    //
    // The number of lines that we expect in the file.  Note that we only
    // support one configuration (slot 0).
    //
    fn lines(&self) -> usize {
        const NUM_CONFIGS: usize = 1;

        match self {
            RendmpDevice::RendmpGenTwo(_) => 290 + (358 * NUM_CONFIGS),
            RendmpDevice::RendmpGenTwoFive(_) => 273 + (309 * NUM_CONFIGS),
        }
    }

    //
    // This is a little nuts: this is the line-offset in the file that contains
    // the data payload that is the CRC.  And yes, this is the defined way of
    // getting this...
    //
    fn crc_line(&self) -> usize {
        match self {
            RendmpDevice::RendmpGenTwo(_) => 600,
            RendmpDevice::RendmpGenTwoFive(_) => 526,
        }
    }

    fn slot_addr(&self) -> [u8; 2] {
        match self {
            RendmpDevice::RendmpGenTwo(_) => 0x00c2u16,
            RendmpDevice::RendmpGenTwoFive(_) => 0x00c4u16,
        }
        .to_le_bytes()
    }

    fn crc_addr(&self) -> [u8; 2] {
        match self {
            RendmpDevice::RendmpGenTwo(_) => 0x003fu16,
            RendmpDevice::RendmpGenTwoFive(_) => 0x003cu16,
        }
        .to_le_bytes()
    }

    fn programmer_status_addr(&self) -> [u8; 2] {
        0x0707u16.to_le_bytes()
    }

    fn bank_status_addr(&self) -> [u8; 2] {
        0x0709u16.to_le_bytes()
    }

    fn check_programmer_status(&self, status: u16) -> Result<()> {
        if status & 0b0_0000_0001 == 1 {
            Ok(())
        } else if status & 0b0_0001_0000 != 0 {
            bail!("flashing failed: CRC mismatch within RAM data");
        } else if status & 0b0_0100_0000 != 0 {
            bail!("flashing failed: CRC mismatch within OTP data");
        } else if status & 0b1_0000_0000 != 0 {
            bail!("flashing failed: configurations not available");
        } else {
            bail!("flashing failed: unknown failure (status 0x{:x})", status);
        }
    }

    fn bank_status(
        &self,
        status: &[u8],
    ) -> Result<Vec<Option<RendmpBankStatus>>> {
        let mut rval = vec![];

        if status.len() != 8 {
            bail!("short bank status");
        }

        for s in status {
            rval.push(RendmpBankStatus::from_u8(s & 0b1111));
            rval.push(RendmpBankStatus::from_u8((s >> 4) & 0b1111));
        }

        Ok(rval)
    }
}

#[derive(Copy, Clone, Debug, FromPrimitive)]
enum RendmpHexRecordKind {
    Data = 0,
    Header = 0x49,
}

//
// A structure for the Renesas HEX file, as documented in the Renesas Digital
// Multiphase Programming Guide (both Gen 2 and Gen 2.5).
//
#[allow(dead_code)]
struct RendmpHex {
    device: RendmpDevice,
    ic_device_id: [u8; 4],
    ic_device_rev: [u8; 4],
    crc: u32,
    data: Vec<Vec<u8>>,
}

impl RendmpHex {
    fn from_file(filename: &str, address: u8) -> Result<Self> {
        let file = fs::File::open(filename)?;
        let lines = BufReader::new(file).lines();

        let mut data = vec![];
        let mut headers = vec![];

        //
        // The IC_DEVICE_ID and IC_DEVICE_REV are (inexplicably?) big-endian in
        // the HEX file -- even though they are little-endian off the device.
        // This is a convenience routine to flip them.
        //
        fn flip_word(val: &[u8], what: &'static str) -> Result<[u8; 4]> {
            if val.len() != 4 {
                bail!("bad {} length (found {} bytes)", what, val.len());
            }

            Ok([val[3], val[2], val[1], val[0]])
        }

        for (ndx, line) in lines.enumerate() {
            let line = line?;
            let l = ndx + 1;

            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            let mut vals = vec![];

            for i in (0..line.len()).step_by(2) {
                let col = i + 1;

                if i + 1 >= line.len() {
                    bail!("short hex input on line {} in column {}", l, col);
                }

                let s = &line[i..i + 2];

                if let Ok(val) = u8::from_str_radix(s, 16) {
                    vals.push(val);
                } else {
                    bail!(
                        "bad hex value on line {} in column {}: {}",
                        l,
                        col,
                        s
                    );
                }
            }

            //
            // We expect at least a record kind, length, and CRC.
            //
            if vals.len() < 2 {
                bail!("short hex input on line {}", l);
            }

            let kind = match RendmpHexRecordKind::from_u8(vals[0]) {
                Some(kind) => kind,
                None => {
                    bail!("bad record kind 0x{:x} on line {}", vals[0], l);
                }
            };

            let reclen = vals[1] as usize;

            if reclen != vals.len() - 2 {
                bail!("bad record length {} on line {}", vals[1], l);
            }

            //
            // This is in principle possible to support (that is, we could
            // flash a different address than the one in the HEX file), but
            // it seems much more likely that someone is trying to flash the
            // wrong device -- and we want to preserve this as a check.
            //
            if vals[2] >> 1 != address {
                bail!(
                    "image specifies address to be 0x{:x}; can't flash 0x{:x}",
                    vals[2] >> 1,
                    address
                );
            }

            let payload = vals[3..reclen + 1].to_vec();

            match kind {
                RendmpHexRecordKind::Header => headers.push(payload),
                RendmpHexRecordKind::Data => data.push(payload),
            }
        }

        //
        // We expect at least our IC_DEVICE_ID and IC_DEVICE_REV as headers,
        // in that order.
        //
        if headers.len() < 2 {
            bail!("insufficient headers found");
        }

        let ic_device_id = flip_word(&headers[0][1..], "IC_DEVICE_ID")?;
        let device = RendmpDevice::from_id(ic_device_id[1])?;

        let found = headers.len() + data.len();
        let expected = device.lines();

        if found != expected {
            bail!("expected {} total lines, found {}", expected, found);
        }

        //
        // Pull our CRC out of the image.
        //
        let crc_line = device.crc_line();
        let crc = &data[crc_line - headers.len() - 1][1..];

        if crc.len() != 4 {
            bail!("bad CRC length on line {}: {}", crc_line, crc.len());
        }

        Ok(Self {
            device,
            ic_device_id,
            ic_device_rev: flip_word(&headers[1][1..], "IC_DEVICE_REV")?,
            crc: u32::from_le_bytes(crc.try_into().unwrap()),
            data,
        })
    }
}

fn all_commands(
    device: pmbus::Device,
) -> HashMap<String, (u8, pmbus::Operation, pmbus::Operation)> {
    let mut all = HashMap::new();

    for i in 0..=255u8 {
        device.command(i, |cmd| {
            all.insert(
                cmd.name().to_string(),
                (i, cmd.read_op(), cmd.write_op()),
            );
        });
    }

    all
}

#[derive(Copy, Clone, Debug)]
enum Address<'a> {
    Dma(u16),
    Pmbus(u8, &'a str),
}

struct Packet<'a> {
    address: Address<'a>,
    payload: Vec<u8>,
}

fn rendmp_gen(
    _subargs: &RendmpArgs,
    device: &pmbus::Device,
    packets: &[Packet],
    commands: &HashMap<String, (u8, pmbus::Operation, pmbus::Operation)>,
) -> Result<()> {
    println!(
        r##"// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

///
/// Iterate over a configuration payload for a Renesas {} digital multiphase
/// PWM controller.  This code was generated by "humility rendmp -g" given
/// a .txt dump from running Renesas configuration software.
///
#[rustfmt::skip]
pub fn {}_payload<E>(
    mut func: impl FnMut(&[u8]) -> Result<(), E>
) -> Result<(), E> {{

    const PAYLOAD: &[&[u8]] = &["##,
        device.name(),
        device.name(),
    );

    let dmaaddr = match commands.get("DMAADDR") {
        Some((code, _, write)) => {
            if *write != pmbus::Operation::WriteWord {
                bail!("DMAADDR mismatch: found {:?}", write);
            }
            *code
        }
        _ => {
            bail!("no DMAADDR command found; is this a Renesas device?");
        }
    };

    let dmafix = match commands.get("DMAFIX") {
        Some((code, _, write)) => {
            if *write != pmbus::Operation::WriteWord32 {
                bail!("DMADATA mismatch: found {:?}", write);
            }
            *code
        }
        _ => {
            bail!("no DMAFIX command found; is this a Renesas device?");
        }
    };

    for packet in packets {
        match packet.address {
            Address::Dma(addr) => {
                let p = addr.to_le_bytes();

                println!("        // DMAADDR = 0x{:04x}", addr);
                println!(
                    "        &[ 0x{:02x}, 0x{:02x}, 0x{:02x} ],\n",
                    dmaaddr, p[0], p[1]
                );

                println!("        // DMAFIX = {:x?}", packet.payload);
                print!("        &[ 0x{:02x}, ", dmafix);
            }

            Address::Pmbus(code, name) => {
                println!("        // {} = {:x?}", name, packet.payload);

                print!("        &[ 0x{:02x}, ", code);
            }
        }

        for byte in &packet.payload {
            print!("0x{:02x}, ", byte);
        }

        println!("],\n");
    }

    println!(
        r##"    ];

    for chunk in PAYLOAD {{
        func(chunk)?;
    }}

    Ok(())
}}"##
    );

    Ok(())
}

fn rendmp_ingest(subargs: &RendmpArgs) -> Result<()> {
    let filename = subargs.ingest.as_ref().unwrap();
    let file = fs::File::open(filename)?;
    let lines = BufReader::new(file).lines();

    let mut allcmds = HashMap::new();
    let mut packets = vec![];

    let device = if let Some(driver) = &subargs.dev.driver {
        match pmbus::Device::from_str(driver) {
            Some(device) => device,
            None => {
                bail!("unknown device \"{}\"", driver);
            }
        }
    } else {
        bail!("must specify device driver");
    };

    for code in 0..0xffu8 {
        device.command(code, |cmd| {
            allcmds.insert(code, cmd.name());
        });
    }

    for (ndx, line) in lines.enumerate() {
        let line = line?;
        let lineno = ndx + 1;

        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let contents = line.split_whitespace().collect::<Vec<_>>();

        if contents.len() != 4 || contents[2] != "#" {
            bail!("malformed line {}", lineno);
        }

        let payload = contents[1];

        if !payload.starts_with("0x") {
            bail!("bad payload prefix on line {}: {}", lineno, payload);
        }

        let payload = match payload.len() {
            4 => match parse_int::parse::<u8>(payload) {
                Ok(val) => val.to_le_bytes().to_vec(),
                Err(_) => {
                    bail!("bad payload on line {}: {}", lineno, payload);
                }
            },

            6 => match parse_int::parse::<u16>(payload) {
                Ok(val) => val.to_le_bytes().to_vec(),
                Err(_) => {
                    bail!("bad payload on line {}: {}", lineno, payload);
                }
            },

            10 => match parse_int::parse::<u32>(payload) {
                Ok(val) => val.to_le_bytes().to_vec(),
                Err(_) => {
                    bail!("bad payload on line {}: {}", lineno, payload);
                }
            },

            _ => {
                bail!("badly sized payload on line {}: {}", lineno, payload);
            }
        };

        let address = contents[3];

        //
        // This is lame, but the only way to differentiate PMBus writes
        // (single-byte address) from DMA writes (dual-byte) is to look
        // at length of the string:
        //
        if !address.starts_with("0x") {
            bail!("bad address on line {}: {}", lineno, address);
        }

        let address = if address.len() > 4 {
            match parse_int::parse::<u16>(address) {
                Ok(dmaaddr) => Address::Dma(dmaaddr),
                Err(_) => {
                    bail!("bad DMA address on line {}: {}", lineno, address);
                }
            }
        } else {
            match parse_int::parse::<u8>(address) {
                Ok(paddr) => {
                    Address::Pmbus(paddr, allcmds.get(&paddr).unwrap())
                }
                Err(_) => {
                    bail!("bad PMBus address on line {}: {}", lineno, address);
                }
            }
        };

        packets.push(Packet { address, payload });
    }

    packets.push(Packet {
        address: Address::Pmbus(0xe7, allcmds.get(&0xe7).unwrap()),
        payload: vec![1, 0],
    });

    let commands = all_commands(device);
    rendmp_gen(subargs, &device, &packets, &commands)?;

    Ok(())
}

/// A device which supports open-pin detection and other advanced debug
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
enum SupportedDevice {
    ISL68224,
    RAA229618,
}

impl SupportedDevice {
    /// Number of rails supported by this device
    fn rails(&self) -> usize {
        match self {
            SupportedDevice::ISL68224 => 3,
            SupportedDevice::RAA229618 => 2,
        }
    }

    /// Returns a list of phases and their numbering
    fn phases(&self) -> Vec<(String, u32)> {
        match &self {
            SupportedDevice::ISL68224 => {
                let mut phases = vec![];
                for phase in 0..6 {
                    phases.push((phase.to_string(), phase + 3));
                }
                for i in 0..3 {
                    phases.push((format!("VSEN{i}"), i + 12));
                }
                phases
            }
            SupportedDevice::RAA229618 => {
                let mut phases = vec![];
                for phase in 0..20 {
                    phases.push((phase.to_string(), phase));
                }
                for i in 0..2 {
                    phases.push((format!("VSEN{i}"), i + 20));
                }
                phases
            }
        }
    }
}

impl std::fmt::Display for SupportedDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let s = match self {
            SupportedDevice::ISL68224 => "ISL68224",
            SupportedDevice::RAA229618 => "RAA229618",
        };
        write!(f, "{s}")
    }
}

/// Checks that the address provided is valid
///
/// This checks that the address uniquely points to an RAA229618 or ISL68224.
/// In theory, this is not guaranteed; we could build a board that has chips on
/// multiple I2C buses.  In practice, however, we have maintained unique
/// addresses for power chips on all of our boards.
fn check_addr(
    subargs: &RendmpArgs,
    hubris: &HubrisArchive,
) -> Result<(u8, SupportedDevice)> {
    const ISL_DEV_NAME: &str = "isl68224";
    const RAA_DEV_NAME: &str = "raa229618";

    if let Some(rail) = &subargs.dev.rail {
        for d in &hubris.manifest.i2c_devices {
            if let HubrisI2cDeviceClass::Pmbus { rails } = &d.class {
                if rails.iter().any(|r| r.name == *rail) {
                    let dev = match d.device.as_str() {
                        ISL_DEV_NAME => SupportedDevice::ISL68224,
                        RAA_DEV_NAME => SupportedDevice::RAA229618,
                        _ => {
                            bail!("rail {rail} is not a supported device");
                        }
                    };

                    return Ok((d.address, dev));
                }
            }
        }

        bail!("{rail} is not a valid rail");
    }

    let Some(addr) = &subargs.dev.device else {
        bail!("must specify I2C address with --device");
    };
    let addr: u8 = parse_int::parse(addr).context("failed to parse address")?;
    let mut iter = hubris.manifest.i2c_devices.iter().filter(|dev| {
        matches!(dev.device.as_str(), RAA_DEV_NAME | ISL_DEV_NAME)
            && dev.address == addr
    });
    let Some(dev) = iter.next() else {
        bail!(
            "no RAA229618 or ISL68224 with address {addr}; \
             use `humility pmbus -l` to list devices"
        );
    };
    if iter.next().is_some() {
        bail!(
            "there are multiple devices with address {addr}; \
             this should not be possible on an Oxide board"
        )
    }
    let dev = match dev.device.as_str() {
        ISL_DEV_NAME => SupportedDevice::ISL68224,
        RAA_DEV_NAME => SupportedDevice::RAA229618,
        _ => unreachable!(), // checked above
    };

    Ok((addr, dev))
}

fn rendmp_blackbox(
    subargs: RendmpArgs,
    hubris: &HubrisArchive,
    core: &mut dyn humility::core::Core,
    context: &mut HiffyContext,
) -> Result<()> {
    let (addr, _dev) = check_addr(&subargs, hubris)?;
    let op = hubris.get_idol_command("Power.rendmp_blackbox_dump")?;
    let value =
        hiffy_call(hubris, core, context, &op, &[("addr", addr.into())], None)?;
    match value {
        Ok(Value::Enum(e)) => {
            let contents = e
                .contents()
                .ok_or_else(|| anyhow!("missing contents in blackbox enum"))?;
            let Value::Tuple(c) = contents else {
                bail!("missing tuple in blackbox enum");
            };
            let Value::Array(a) = &c[0] else {
                bail!("missing array in blackbox enum");
            };
            let mut data = vec![];
            for word in a.iter() {
                let Value::Base(Base::U32(b)) = word else {
                    bail!("unexpected type in array: {word:?}");
                };
                data.extend(b.as_bytes());
            }
            match e.disc() {
                "Gen2p5" => println!(
                    "{}",
                    blackbox::BlackboxRamGen2p5::read_from(data.as_slice())
                        .ok_or_else(|| anyhow!(
                            "could not load blackbox from bytes"
                        ))?,
                ),
                "Gen2" => println!(
                    "{}",
                    blackbox::BlackboxRamGen2::read_from(data.as_slice())
                        .ok_or_else(|| anyhow!(
                            "could not load blackbox from bytes"
                        ))?,
                ),
                v => bail!("unknown blackbox gen: {v:?}"),
            };
        }
        Ok(other) => bail!("unexpected value: {other:?}"),
        Err(e) => bail!("got error: {e:?}"),
    }

    Ok(())
}

/// Reads and decodes open-pin registers on the selected device
fn get_pin_states(
    subargs: &RendmpArgs,
    hubris: &HubrisArchive,
    core: &mut dyn humility::core::Core,
    context: &mut HiffyContext,
) -> Result<BTreeMap<String, PinState>> {
    let (addr, dev) = check_addr(subargs, hubris)?;
    let op = hubris.get_idol_command("Power.rendmp_dma_read")?;

    let regs: &'static [u16] = match dev {
        SupportedDevice::ISL68224 => &[
            0x00BD, // open-pin
            0xE925, // mask
        ],
        SupportedDevice::RAA229618 => &[
            0x00BE, 0x00BF, // open-pin
            0xE904, 0xE905, // mask
        ],
    };
    let mut ops = vec![];
    for &r in regs {
        let payload =
            op.payload(&[("addr", addr.into()), ("reg", r.into())])?;
        context.idol_call_ops(&op, &payload, &mut ops)?;
    }
    ops.push(hif::Op::Done);
    let results = context.run(core, ops.as_slice(), None)?;

    // Decode Hiffy results
    let mut values = vec![];
    for r in results {
        match hiffy_decode(hubris, &op, r)? {
            Err(e) => bail!("hiffy error: {e}"),
            Ok(Value::Base(Base::U32(b))) => values.push(b),
            v => bail!("unexpected type in result: {v:?}"),
        }
    }

    let phases = dev.phases();

    // Register decoding was determined with a mix of Power Navigator
    // experiments and discussion with Renesas.
    let (open, mask) = match dev {
        SupportedDevice::ISL68224 => (values[0] as u64, values[1] as u64),
        SupportedDevice::RAA229618 => {
            let open = values[0] as u64 | (values[1] as u64) << 32;
            let mask = values[2] as u64 | (values[3] as u64) << 32;
            (open, mask)
        }
    };
    let mut out = BTreeMap::new();
    for (name, n) in phases {
        // Each phase is represented by two-bit values in the open and mask
        // registers.  We ignore bits in the open register that aren't set in
        // the mask register:
        let bit_offset = n * 2;
        let is_open = (open & mask & (0b11 << bit_offset)) != 0;

        // If there are no bits set in the mask register, then the phase isn't
        // used at all, so we'll print that instead.
        let is_mask = mask & (0b11 << bit_offset) == 0;
        if is_mask {
            out.insert(name, PinState::Masked);
        } else if is_open {
            out.insert(name, PinState::Open);
        } else {
            out.insert(name, PinState::Good);
        }
    }

    Ok(out)
}

fn rendmp_open_pin(
    subargs: &RendmpArgs,
    hubris: &HubrisArchive,
    core: &mut dyn humility::core::Core,
    context: &mut HiffyContext,
) -> Result<()> {
    let (addr, dev) = check_addr(subargs, hubris)?;
    let phases = dev.phases();
    let out = get_pin_states(subargs, hubris, core, context)?;
    println!("Open pin check for {dev} at {addr:#x}");
    println!(" {} | {}", "PHASE".bold(), "STATE".bold());
    println!("-------|-------");
    for (name, _) in &phases {
        print!(" {name:<5} | ");
        match out[name] {
            PinState::Masked => println!("{}", "N/A (masked)".dimmed()),
            PinState::Open => println!("{}", "open".red()),
            PinState::Good => println!("{}", "okay".green()),
        }
    }
    Ok(())
}

#[derive(Copy, Clone, Debug)]
enum Call {
    ReadDma(u32),
    WriteDma,
    ReadByte(u8),
    ReadWord(u16),
    ReadWord32(u32),
    WriteByte,
    WriteWord,
    WriteWord32,
}
impl Call {
    fn expect_read_dma(&self) -> Result<u32> {
        if let Call::ReadDma(v) = self {
            Ok(*v)
        } else {
            bail!("unexpected call result {self:?}; expected ReadDma")
        }
    }
    fn expect_write_dma(&self) -> Result<()> {
        if let Call::WriteDma = self {
            Ok(())
        } else {
            bail!("unexpected call result {self:?}; expected WriteDma")
        }
    }
    fn expect_read_word32(&self) -> Result<u32> {
        if let Call::ReadWord32(v) = self {
            Ok(*v)
        } else {
            bail!("unexpected call result {self:?}; expected ReadWord32")
        }
    }
    fn expect_write_word32(&self) -> Result<()> {
        if let Call::WriteWord32 = self {
            Ok(())
        } else {
            bail!("unexpected call result {self:?}; expected WriteWord32")
        }
    }
    fn expect_read_word(&self) -> Result<u16> {
        if let Call::ReadWord(v) = self {
            Ok(*v)
        } else {
            bail!("unexpected call result {self:?}; expected ReadWord")
        }
    }
    fn expect_write_word(&self) -> Result<()> {
        if let Call::WriteWord = self {
            Ok(())
        } else {
            bail!("unexpected call result {self:?}; expected WriteWord")
        }
    }
    fn expect_read_byte(&self) -> Result<u8> {
        if let Call::ReadByte(v) = self {
            Ok(*v)
        } else {
            bail!("unexpected call result {self:?}; expected Byte")
        }
    }
    fn expect_write_byte(&self) -> Result<()> {
        if let Call::WriteByte = self {
            Ok(())
        } else {
            bail!("unexpected call result {self:?}; expected WriteByte")
        }
    }
}

struct HifWorker<'a, 'b> {
    hubris: &'a HubrisArchive,
    context: &'a mut HiffyContext<'b>,

    read_dma: IdolOperation<'a>,
    write_dma: IdolOperation<'a>,

    read_byte: IdolOperation<'a>,
    read_word: IdolOperation<'a>,
    read_word32: IdolOperation<'a>,

    write_byte: IdolOperation<'a>,
    write_word: IdolOperation<'a>,
    write_word32: IdolOperation<'a>,

    ops: Vec<hif::Op>,
    calls: Vec<Call>,

    rail_indexes: Vec<u32>,

    /// Mapping from a phase (in the chip sense) to a tuple of `(rail, name)`.
    ///
    /// - `rail` is an index into `self.rail_indexes`
    /// - `name` is the name of that rail
    ///
    /// This means that names are duplicated (since each rail has multiple
    /// phases), but that's not a huge amount of memory overhead.
    phase_to_rail: BTreeMap<u8, (usize, String)>,
}

impl<'a, 'b> HifWorker<'a, 'b> {
    fn new<'c>(
        hubris: &'a HubrisArchive,
        context: &'a mut HiffyContext<'b>,
        core: &'c mut dyn humility::core::Core,
        i2c_addr: u8,
    ) -> Result<Self> {
        let read_dma = hubris.get_idol_command("Power.rendmp_dma_read")?;
        let write_dma = hubris.get_idol_command("Power.rendmp_dma_write")?;
        let read_byte = hubris.get_idol_command("Power.raw_pmbus_read_byte")?;
        let read_word = hubris.get_idol_command("Power.raw_pmbus_read_word")?;
        let read_word32 =
            hubris.get_idol_command("Power.raw_pmbus_read_word32")?;
        let write_word =
            hubris.get_idol_command("Power.raw_pmbus_write_word")?;
        let write_byte =
            hubris.get_idol_command("Power.raw_pmbus_write_byte")?;
        let write_word32 =
            hubris.get_idol_command("Power.raw_pmbus_write_word32")?;

        let sensor_id_map = humility_pmbus::sensor_id_map(hubris, core)?;
        let dev_index = hubris
            .manifest
            .i2c_devices
            .iter()
            .enumerate()
            .find(|(_i, dev)| dev.address == i2c_addr)
            .ok_or_else(|| {
                anyhow!("could not find device at addr {i2c_addr:?}")
            })?
            .0;

        // Compute the mapping from phases to rails
        let mut phase_to_rail = BTreeMap::new();
        if let HubrisI2cDeviceClass::Pmbus { rails } =
            &hubris.manifest.i2c_devices[dev_index].class
        {
            for (i, rail) in rails.iter().enumerate() {
                for phase in rail.phases.iter().flatten() {
                    phase_to_rail.insert(*phase, (i, rail.name.clone()));
                }
            }
        } else {
            bail!("expected PMBus class");
        }

        let rail_indexes: Vec<_> = hubris
            .manifest
            .sensors
            .iter()
            .enumerate()
            .filter(|(_i, s)| {
                s.device == HubrisSensorDevice::I2c(dev_index)
                    && s.kind == HubrisSensorKind::Voltage
            })
            .map(|(sensor_id, _s)| {
                // This rail's voltage sensor is the n'th voltage sensor among
                // voltage sensors that match the target device.  Convert from
                // voltage sensor index to device index for use in
                // Power.read/write_* APIs.
                sensor_id_map
                    .get(&(sensor_id as u32))
                    .ok_or_else(|| {
                        anyhow!(
                            "could not find sensor {sensor_id} \
                            in CONTROLLER_CONFIG"
                        )
                    })
                    .map(|i| *i as u32)
            })
            .collect::<Result<Vec<_>>>()?;

        Ok(Self {
            hubris,
            context,

            read_dma,
            write_dma,
            read_byte,
            read_word,
            read_word32,
            write_byte,
            write_word,
            write_word32,

            ops: vec![],
            calls: vec![],

            rail_indexes,
            phase_to_rail,
        })
    }

    fn write_dma(&mut self, i2c_addr: u8, reg: u16, data: u32) -> Result<()> {
        let payload = self.write_dma.payload(&[
            ("addr", i2c_addr.into()),
            ("reg", reg.into()),
            ("data", data.into()),
        ])?;
        self.context.idol_call_ops(&self.write_dma, &payload, &mut self.ops)?;
        self.calls.push(Call::WriteDma);
        Ok(())
    }

    fn read_dma(&mut self, i2c_addr: u8, dma_reg: u16) -> Result<()> {
        let payload = self
            .read_dma
            .payload(&[("addr", i2c_addr.into()), ("reg", dma_reg.into())])?;
        self.context.idol_call_ops(&self.read_dma, &payload, &mut self.ops)?;
        self.calls.push(Call::ReadDma(0));
        Ok(())
    }

    fn read_word(&mut self, index: u32, has_rail: bool, op: u8) -> Result<()> {
        let payload = self.read_word.payload(&[
            ("index", index.into()),
            ("has_rail", has_rail.into()),
            ("op", op.into()),
        ])?;
        self.context.idol_call_ops(&self.read_word, &payload, &mut self.ops)?;
        self.calls.push(Call::ReadWord(0));
        Ok(())
    }

    fn write_word(
        &mut self,
        index: u32,
        has_rail: bool,
        op: u8,
        data: u16,
    ) -> Result<()> {
        let payload = self.write_word.payload(&[
            ("index", index.into()),
            ("has_rail", has_rail.into()),
            ("op", op.into()),
            ("data", data.into()),
        ])?;
        self.context.idol_call_ops(
            &self.write_word,
            &payload,
            &mut self.ops,
        )?;
        self.calls.push(Call::WriteWord);
        Ok(())
    }

    fn read_byte(&mut self, index: u32, has_rail: bool, op: u8) -> Result<()> {
        let payload = self.read_byte.payload(&[
            ("index", index.into()),
            ("has_rail", has_rail.into()),
            ("op", op.into()),
        ])?;
        self.context.idol_call_ops(&self.read_byte, &payload, &mut self.ops)?;
        self.calls.push(Call::ReadByte(0));
        Ok(())
    }

    fn write_byte(
        &mut self,
        index: u32,
        has_rail: bool,
        op: u8,
        data: u8,
    ) -> Result<()> {
        let payload = self.write_byte.payload(&[
            ("index", index.into()),
            ("has_rail", has_rail.into()),
            ("op", op.into()),
            ("data", data.into()),
        ])?;
        self.context.idol_call_ops(
            &self.write_byte,
            &payload,
            &mut self.ops,
        )?;
        self.calls.push(Call::WriteByte);
        Ok(())
    }

    fn read_word32(
        &mut self,
        index: u32,
        has_rail: bool,
        op: u8,
    ) -> Result<()> {
        let payload = self.read_word32.payload(&[
            ("index", index.into()),
            ("has_rail", has_rail.into()),
            ("op", op.into()),
        ])?;
        self.context.idol_call_ops(
            &self.read_word32,
            &payload,
            &mut self.ops,
        )?;
        self.calls.push(Call::ReadWord32(0));
        Ok(())
    }

    fn write_word32(
        &mut self,
        index: u32,
        has_rail: bool,
        op: u8,
        data: u32,
    ) -> Result<()> {
        let payload = self.write_word32.payload(&[
            ("index", index.into()),
            ("has_rail", has_rail.into()),
            ("op", op.into()),
            ("data", data.into()),
        ])?;
        self.context.idol_call_ops(
            &self.write_word32,
            &payload,
            &mut self.ops,
        )?;
        self.calls.push(Call::WriteWord32);
        Ok(())
    }

    fn run(
        &mut self,
        core: &mut dyn humility::core::Core,
    ) -> Result<Vec<Result<Call, String>>> {
        let mut ops = std::mem::take(&mut self.ops);
        ops.push(Op::Done);
        let r = self.context.run(core, &ops, None)?;
        if r.len() != self.calls.len() {
            bail!("mismatched result lengths");
        }
        let mut out = vec![];
        for (value, call) in r.into_iter().zip(std::mem::take(&mut self.calls))
        {
            let op = match call {
                Call::ReadDma(..) => &self.read_dma,
                Call::WriteDma => &self.write_dma,
                Call::ReadByte(..) => &self.read_byte,
                Call::ReadWord(..) => &self.read_word,
                Call::ReadWord32(..) => &self.read_word32,
                Call::WriteWord => &self.write_word,
                Call::WriteByte => &self.write_byte,
                Call::WriteWord32 => &self.write_word32,
            };
            let v = hiffy_decode(self.hubris, op, value)
                .context("failed to decode {op:?} result")?;
            match v {
                Ok(v) => {
                    let v = v.as_base().context("expected Base, got {v:?}")?;
                    match (v, call) {
                        (Base::U32(v), Call::ReadDma(..)) => {
                            out.push(Ok(Call::ReadDma(*v)))
                        }
                        (Base::U8(v), Call::ReadByte(..)) => {
                            out.push(Ok(Call::ReadByte(*v)))
                        }
                        (Base::U16(v), Call::ReadWord(..)) => {
                            out.push(Ok(Call::ReadWord(*v)))
                        }
                        (Base::U32(v), Call::ReadWord32(..)) => {
                            out.push(Ok(Call::ReadWord32(*v)))
                        }
                        (Base::U0, Call::WriteDma) => {
                            out.push(Ok(Call::WriteDma))
                        }
                        (Base::U0, Call::WriteWord) => {
                            out.push(Ok(Call::WriteWord))
                        }
                        (Base::U0, Call::WriteByte) => {
                            out.push(Ok(Call::WriteByte))
                        }
                        (Base::U0, Call::WriteWord32) => {
                            out.push(Ok(Call::WriteWord32))
                        }
                        (base, op) => {
                            bail!("got unexpected result {base} for {op:?}")
                        }
                    }
                }
                Err(e) => out.push(Err(e)),
            }
        }
        Ok(out)
    }
}

fn rendmp_phase_check<'a>(
    subargs: &'a RendmpArgs,
    hubris: &'a HubrisArchive,
    core: &mut dyn humility::core::Core,
    context: &'a mut HiffyContext,
) -> Result<()> {
    // Make sure we're in A2 before doing anything
    let power_state_op = hubris
        .get_idol_command("Sequencer.tofino_seq_state")
        .or_else(|_| hubris.get_idol_command("Sequencer.get_state"))
        .context("could not get power state HIF operation")?;
    let r = hiffy_call(hubris, core, context, &power_state_op, &[], None)?;
    if let Err(e) = r {
        bail!("power state check got an error: {e}");
    }
    if hiffy_format_result(hubris, r) != "A2" {
        bail!("must be in A2 when checking phases");
    }

    //
    // We have found that for some (~20%) of the DIMMs we use on Gimlet, the
    // phase check -- which produces about 400 mV -- powers up the Register
    // Clock Driver (RCD) just enough to cause havoc to the I2C bus that the
    // SPD is on (despite the SPD being in a different power domain!).  This is
    // particularly problematic when the SPD's I2C bus is also the I2C bus by
    // which we are communicating with the DMP controller:  we can't tell the
    // controller to stop its phase check, so the bus becomes wedged!  Note
    // that the SP is uninvolved:  the RAA229618 and the DIMM's RCD are locked
    // in a deadly embrace, and no amount of resetting the SP's I2C controller
    // (or the SP itself) will release them.  (It is a bit of a mystery why
    // this only happens to some DIMMs -- but 400 mV is in undefined territory
    // for the RCD, so it's also not hugely surprising that slight process
    // variations would result in different behavior.)
    //
    // To avoid this, we refuse to do the phase check if we find any SPDs (that
    // is, DIMMs) at all.  This could be made more precise (this is only a
    // problem if the phase corresponds to a DIMM rail and the DIMM's SPD
    // shares the I2C bus with the DMP controller -- which is to say, the ABCD
    // bank on Gimlet), but it doesn't seem particularly worth it, especially
    // as the phase check is only used in manufacturing before the DIMM
    // connectors have been press fit.
    //
    // Finally, note that we check for SPDs by bungee jumping into the "spd"
    // command.  If we find a(nother) need for SPD data (and arguably, even if
    // we don't), this should be factored out into a humility-spd crate that
    // both "spd" and "rendmp" would use.
    //
    if cmd_spd::spd_any(hubris, core)? {
        if subargs.force_phase_check {
            warn!(
                "DIMMs are present, but phase check has been forced; if the \
                checked phase powers a DIMM, this may hang the I2C bus!"
            );
        } else {
            bail!(
                "cannot check phases with DIMMs present: if a checked \
                phase powers a DIMM, an I2C hang can result; this can be \
                overridden with --force-phase-check -- but use this carefully"
            );
        }
    }

    // Pick out the target device
    let (addr, dev) = check_addr(subargs, hubris)?;

    // Read pin states so that we don't try to enable a phase with an open-pin
    // failure; this would cause the power controller to lock up.
    let pin_states = get_pin_states(subargs, hubris, core, context)?;

    let mut specified: Option<HashSet<u8>> =
        subargs.phase.as_ref().map(|p| HashSet::from_iter(p.iter().cloned()));

    // Filter out VGEN phases
    let phases: Vec<_> = dev
        .phases()
        .into_iter()
        .filter(|(p, _b)| match (p.parse::<u8>(), &mut specified) {
            (Ok(_), None) => true,
            (Ok(val), Some(s)) => s.remove(&val),
            _ => false,
        })
        .collect();

    // If phases were specified, be sure that we matched them all
    if let Some(s) = &specified {
        if !s.is_empty() {
            bail!("illegal phase(s) specified: {s:?}");
        }
    }

    let mut worker = HifWorker::new(hubris, context, core, addr)?;

    if worker.rail_indexes.len() != dev.rails() {
        bail!("length mismatch between sensors and rails");
    }

    // Read a device-specific DMA registers, which we'll modify to disable
    // faults when we write it back
    let disable_fault_reg: u16 = match dev {
        SupportedDevice::ISL68224 => 0xE952,
        SupportedDevice::RAA229618 => 0xE932,
    };

    ////////////////////////////////////////////////////////////////////////////
    // We're doing to queue up a bunch of HIF operations to prepare.  In some
    // cases, we can unconditionally write to a DMA register or PMBus operation;
    // in other cases, we'll need to read back a value, modify it locally, then
    // write in a second HIF program later.
    let rail_indexes = std::mem::take(&mut worker.rail_indexes);
    for (rail, &index) in rail_indexes.iter().enumerate() {
        // Set the PWM register for this rail; 0x133 denotes 50ns
        let reg = (0xEA31 + rail * 0x80) as u16;
        worker.write_dma(addr, reg, 0x133)?;

        // Read 0xEA0D / 0xEA8D / 0xEB0D (we'll modify-write them later)
        let reg = (0xEA0D + rail * 0x80) as u16;
        worker.read_dma(addr, reg)?;

        use pmbus::commands::raa229618::CommandCode::{
            LOOPCFG, ON_OFF_CONFIG, PEAK_OCUC_COUNT,
        };

        // Read a few PMBus values which will be modified and written back later
        worker.read_byte(index, true, ON_OFF_CONFIG as u8)?;
        worker.read_word32(index, true, LOOPCFG as u8)?;
        worker.read_word(index, true, PEAK_OCUC_COUNT as u8)?;

        // Set PMBus command codes 0xD0 and 0xD1 to 0x8000 (disable VMon)
        match dev {
            SupportedDevice::ISL68224 => {
                use pmbus::commands::isl68224::CommandCode;
                worker.write_word(
                    index,
                    true,
                    CommandCode::VMON_ON as u8,
                    0x8000,
                )?;
                worker.write_word(
                    index,
                    true,
                    CommandCode::VMON_OFF as u8,
                    0x8000,
                )?;
            }
            SupportedDevice::RAA229618 => {
                use pmbus::commands::raa229618::CommandCode;
                worker.write_word(
                    index,
                    true,
                    CommandCode::VIN_ON as u8,
                    0x8000,
                )?;
                worker.write_word(
                    index,
                    true,
                    CommandCode::VIN_OFF as u8,
                    0x8000,
                )?;

                let reg = (0xEA5B + rail * 0x80) as u16;
                worker.read_dma(addr, reg)?;
            }
        }

        worker.read_dma(addr, disable_fault_reg + rail as u16)?;
    }

    // Read VOUT_MODE, which we'll need to interpret voltages
    use pmbus::commands::raa229618::CommandCode::VOUT_MODE;
    worker.read_byte(rail_indexes[0], false, VOUT_MODE as u8)?;

    // Disable all phases
    const PHASE_ENABLE_REG: u16 = 0xE9C2;
    worker.write_dma(addr, PHASE_ENABLE_REG, 0)?;

    let results = worker.run(core)?;

    ////////////////////////////////////////////////////////////////////////////
    // Now, we're going to walk through the results, doing the modify-write
    // portion of various register changes.
    let mut iter = results.iter();
    let mut next = || iter.next().ok_or_else(|| anyhow!("early termination"));
    let mut ctrl = vec![];
    let mut on_off_config = vec![];
    for (rail, &index) in rail_indexes.iter().enumerate() {
        if let Err(e) = next()? {
            bail!("failed to write PWM register for rail {rail}: {e}");
        }
        // EA0D / EA8D / EB0D
        match next()? {
            Ok(v) => ctrl.push(v.expect_read_dma()?),
            Err(e) => bail!("failed to read EA0D for rail {rail}: {e}"),
        };

        // Record ON_OFF_CONFIG, which we'll use to actually force the rail on
        match next()? {
            Ok(v) => on_off_config.push(v.expect_read_byte()?),
            Err(e) => {
                bail!("failed to read ON_OFF_CONFIG for rail {rail}: {e}")
            }
        };

        // Modify LOOPCFG (F0h) and write it back
        let mut loopcfg = match next()? {
            Ok(v) => v.expect_read_word32()?,
            Err(e) => bail!("failed to read LOOPCFG for rail {rail}: {e}"),
        };
        loopcfg &= !(
            // Disable APD
            (1 << 0)
            // Disable diode emulation
            | (1 << 6)
            // ??
            | (0b11 << 16)
            // Disble diode emulation for PS0/1
            | (1 << 28)
        );
        use pmbus::commands::raa229618::CommandCode::LOOPCFG;
        worker.write_word32(index, true, LOOPCFG as u8, loopcfg)?;

        // Modify PEAK_OCUC_COUNT (E9h) and write it back
        let mut peak_ocuc_count = match next()? {
            Ok(v) => v.expect_read_word()?,
            Err(e) => {
                bail!("failed to read PEAK_OCUC_COUNT for rail {rail}: {e}",)
            }
        };
        // Clear bits 8:15 to disable undercurrent faults
        peak_ocuc_count &= !(0xFF << 8);
        use pmbus::commands::raa229618::CommandCode::PEAK_OCUC_COUNT;
        worker.write_word(
            index,
            true,
            PEAK_OCUC_COUNT as u8,
            peak_ocuc_count,
        )?;

        match dev {
            SupportedDevice::ISL68224 => {
                if let Err(e) = next()? {
                    bail!("failed to set VMON_ON for {rail}: {e}",);
                }
                if let Err(e) = next()? {
                    bail!("failed to set VMON_OFF for {rail}: {e}",);
                }
            }
            SupportedDevice::RAA229618 => {
                if let Err(e) = next()? {
                    bail!("failed to set VIN_ON for {rail}: {e}",);
                }
                if let Err(e) = next()? {
                    bail!("failed to set VIN_OFF for {rail}: {e}",);
                }

                // Clear bit 0 of DMA register EA5B and write it back
                // (the name part_fast_add comes from Power Navigator)
                let mut part_fast_add = match next()? {
                    Ok(v) => v.expect_read_dma()?,
                    Err(e) => {
                        bail!("worker.failed to read EA5B for rail {rail}: {e}")
                    }
                };
                part_fast_add &= !1; // clear bit 0
                let reg = (0xEA5B + rail * 0x80) as u16;
                worker.write_dma(addr, reg, part_fast_add)?;
            }
        }

        let mut disable_fault_value = match next()? {
            Ok(v) => v.expect_read_dma()?,
            Err(e) => bail!("failed to read {disable_fault_reg:x}: {e}"),
        };
        // clear bits 0:3 and 17:18;
        // this disables all input and output voltage faults.
        disable_fault_value &= !(0b1111 | (0b11 << 17));
        worker.write_dma(
            addr,
            disable_fault_reg + rail as u16,
            disable_fault_value,
        )?;
    }

    let vout_mode = match next()? {
        Ok(v) => v.expect_read_byte()?,
        Err(e) => bail!("failed to read VOUT_MODE: {e}"),
    };
    let vout_mode = || pmbus::commands::VOUT_MODE::CommandData(vout_mode);

    match next()? {
        Ok(v) => v.expect_write_dma()?,
        Err(e) => {
            bail!("failed to disable all phases: {e}")
        }
    }

    if let Some(i) = iter.next() {
        bail!("expected iterator to be done; got {i:?} instead");
    }

    ///////////////////////////////////////////////////////////////////////////
    // Check the results of the modify-write portion of register changes
    let results = worker.run(core)?;
    let mut iter = results.iter();
    let mut next = || iter.next().ok_or_else(|| anyhow!("early termination"));
    for (rail, ..) in rail_indexes.iter().enumerate() {
        match next()? {
            Ok(v) => v.expect_write_word32()?,
            Err(e) => {
                bail!("failed to modify LOOPCFG for rail {rail}: {e}")
            }
        }
        match next()? {
            Ok(v) => v.expect_write_word()?,
            Err(e) => {
                bail!("failed to modify PEAK_OCUC_COUNT for rail {rail}: {e}")
            }
        }
        match dev {
            SupportedDevice::RAA229618 => match next()? {
                Ok(v) => v.expect_write_dma()?,
                Err(e) => {
                    bail!("failed to modify EA5B for rail {rail}: {e}")
                }
            },
            SupportedDevice::ISL68224 => {
                // no changes were made specifically for the ISL68224
            }
        }
        match next()? {
            Ok(v) => v.expect_write_dma()?,
            Err(e) => {
                bail!("failed to disable faults: {e}")
            }
        }
    }

    if let Some(i) = iter.next() {
        bail!("expected iterator to be done; got {i:?} instead");
    }

    ////////////////////////////////////////////////////////////////////////////
    // At this point, every phase is disabled and we're ready to turn on the
    // system.  To enable system, we select a phase by modifying 0xE9C2, then
    // write 0xEA0D/0xEA8D/0xEB0D with the following modifications:
    // - bit 2 is set to 0 (fixed frequency mode)
    // - bit 0 is set to 1 (enable)
    //
    // The basic loop is as follows:
    // - Select phase
    // - Enable rail
    // - Wait a little while
    // - Measure current + voltage
    // - Disable rail
    println!("Phase check for {} at {addr:#x}", format!("{dev}").bold());
    println!(
        "{} |    {}    |    {}    |    {}    | {}",
        "PHASE".bold(),
        "VOUT".bold(),
        "IOUT".bold(),
        "TEMP".bold(),
        "RAIL".bold(),
    );
    println!("------|------------|------------|------------|------------");

    for (phase_name, i) in &phases {
        match pin_states[phase_name] {
            PinState::Open => {
                println!(
                    "{}",
                    format!(" {phase_name:<4} | [skipping open phase]")
                        .dimmed()
                );
                continue;
            }
            PinState::Masked => {
                println!(
                    "{}",
                    format!(" {phase_name:<4} | [skipping masked phase]")
                        .dimmed()
                );
                continue;
            }
            PinState::Good => (),
        }

        // Enable this phase
        worker.write_dma(addr, 0xE9C2, 1 << i)?;

        // This is a little awkward: the values in the `phases` array are bit
        // values as an offset into DMA registers, which doesn't quite map to
        // phase values in our manifest.  However, the phase *name* corresponds
        // to the phase value, so we'll parse the name here.
        let rail = worker
            .phase_to_rail
            .get(&phase_name.parse().unwrap())
            .ok_or_else(|| anyhow!("could not get rail for {phase_name}"))?
            .0;
        let ctrl_addr = (0xEA0D + 0x80 * rail) as u16;
        let index = rail_indexes[rail];
        // Not totally sure if these operations need to be separate, but we
        // were seeing processor errors under certain circumstances.

        let c = ctrl[rail] & !(1 << 2); // ripple regulator: forced-freq PWM
        worker.write_dma(addr, ctrl_addr, c)?;

        let c = c | 1; // fixed PWM mode
        worker.write_dma(addr, ctrl_addr, c)?;

        // Force the rail on
        use pmbus::commands::raa229618::CommandCode::ON_OFF_CONFIG;
        worker.write_byte(index, true, ON_OFF_CONFIG as u8, 0)?;

        // Execute this operation and confirm that it worked
        let results = worker.run(core)?;
        let mut iter = results.iter();
        let mut next =
            || iter.next().ok_or_else(|| anyhow!("early termination"));
        match next()? {
            Ok(v) => v.expect_write_dma()?,
            Err(e) => bail!("failed to enable phase {phase_name}: {e}"),
        }
        match next()? {
            Ok(v) => v.expect_write_dma()?,
            Err(e) => bail!(
                "failed to enable forced-freq pwm for phase {phase_name}: {e}"
            ),
        }
        match next()? {
            Ok(v) => v.expect_write_dma()?,
            Err(e) => {
                bail!("failed to enable pwm mode for phase {phase_name}: {e}")
            }
        }
        match next()? {
            Ok(v) => v.expect_write_byte()?,
            Err(e) => {
                bail!("failed to enable rail {rail} for {phase_name}: {e}")
            }
        }
        if let Some(i) = iter.next() {
            bail!("expected iterator to be done; got {i:?} instead");
        }

        // Give values time to settle
        std::thread::sleep(std::time::Duration::from_millis(100));

        // Read current and voltage from all rails
        worker.read_word(index, true, pmbus::CommandCode::READ_VOUT as u8)?;
        worker.read_word(index, true, pmbus::CommandCode::READ_IOUT as u8)?;
        worker.read_word(
            index,
            true,
            pmbus::CommandCode::READ_TEMPERATURE_1 as u8,
        )?;

        // Write back the original rail and ON_OFF_CONFIG values
        let ctrl_addr = (0xEA0D + 0x80 * rail) as u16;
        worker.write_dma(addr, ctrl_addr, ctrl[rail])?;
        worker.write_byte(
            index,
            true,
            ON_OFF_CONFIG as u8,
            on_off_config[rail],
        )?;

        let results = worker.run(core)?;
        let mut iter = results.iter();
        let mut next =
            || iter.next().ok_or_else(|| anyhow!("early termination"));

        let read_vout = match next()? {
            Ok(v) => v.expect_read_word()?,
            Err(e) => bail!("failed to READ_VOUT: {e}"),
        };
        let read_iout = match next()? {
            Ok(v) => v.expect_read_word()?,
            Err(e) => bail!("failed to READ_IOUT: {e}"),
        };
        let read_tout = match next()? {
            Ok(v) => v.expect_read_word()?,
            Err(e) => bail!("failed to READ_TEMPERATURE_1: {e}"),
        };
        let device = match dev {
            SupportedDevice::RAA229618 => pmbus::Device::Raa229618,
            SupportedDevice::ISL68224 => pmbus::Device::Isl68224,
        };

        let mut vout = String::new();
        device
            .interpret(
                pmbus::CommandCode::READ_VOUT as u8,
                read_vout.as_bytes(),
                vout_mode,
                |_field, value| vout = format!("{value}"),
            )
            .map_err(|e| anyhow!("could not interpret READ_VOUT: {e:?}"))?;
        // The voltage `vout` is now a string in the form 0.123V.  We'll parse
        // it back to a float to determine if it's happy or not.
        let vout_okay = if let Some(value) = vout.strip_suffix('V') {
            let v = value.parse::<f32>().context("could not parse voltage")?;
            v > 0.2 && v < 0.5
        } else {
            bail!("invalid format for voltage");
        };
        let mut iout = String::new();
        device
            .interpret(
                pmbus::CommandCode::READ_IOUT as u8,
                read_iout.as_bytes(),
                vout_mode,
                |_field, value| iout = format!("{value}"),
            )
            .map_err(|e| anyhow!("could not interpret READ_IOUT: {e:?}"))?;
        let mut tout = String::new();
        device
            .interpret(
                pmbus::CommandCode::READ_TEMPERATURE_1 as u8,
                read_tout.as_bytes(),
                vout_mode,
                |_field, value| tout = format!("{value}"),
            )
            .map_err(|e| {
                anyhow!("could not interpret READ_TEMPERATURE_1: {e:?}")
            })?;

        let rail_name = worker
            .phase_to_rail
            .get(&phase_name.parse().unwrap())
            .unwrap()
            .1
            .as_str();
        println!(
            " {phase_name:<4} | {:>10} | {iout:>10} | {tout:>10} | {rail_name}",
            if vout_okay { vout.green() } else { vout.yellow() }
        );

        match next()? {
            Ok(v) => v.expect_write_dma()?,
            Err(e) => bail!("could not disable rail {rail}: {e}"),
        }
        match next()? {
            Ok(v) => v.expect_write_byte()?,
            Err(e) => bail!("could not restore ON_OFF_CONFIG for {rail}: {e}"),
        }
        if let Some(i) = iter.next() {
            bail!("expected iterator to be done; got {i:?} instead");
        }
    }

    Ok(())
}

fn restore_default_config<'a>(
    subargs: &RendmpArgs,
    hubris: &'a HubrisArchive,
    core: &mut dyn humility::core::Core,
    context: &'a mut HiffyContext,
) -> Result<()> {
    // Pick out the target device
    let (addr, _dev) = check_addr(subargs, hubris)?;
    let mut worker = HifWorker::new(hubris, context, core, addr)?;

    humility::msg!("restoring default configuration...");
    use pmbus::commands::raa229618::CommandCode::RESTORE_CFG;
    worker.write_byte(worker.rail_indexes[0], false, RESTORE_CFG as u8, 0)?;
    let r = worker.run(core)?;
    if r.len() != 1 {
        bail!("invalid result len");
    }
    match &r[0] {
        Ok(v) => v.expect_write_byte()?,
        Err(e) => bail!("{e}"),
    }
    humility::msg!("done restoring default configuration...");
    Ok(())
}

fn rendmp(context: &mut ExecutionContext) -> Result<()> {
    let Subcommand::Other(subargs) = context.cli.cmd.as_ref().unwrap();
    let hubris = context.archive.as_mut().unwrap();

    let core = &mut **context.core.as_mut().unwrap();

    let subargs = RendmpArgs::try_parse_from(subargs)?;

    // Workaround for clap#4707
    if subargs.flash.is_none() {
        if subargs.dryrun {
            bail!("--dryrun requires --flash");
        } else if subargs.force {
            bail!("--force requires --flash");
        } else if subargs.check {
            bail!("--check requires --flash");
        }
    }

    if subargs.ingest.is_some() {
        return rendmp_ingest(&subargs);
    }

    let mut context = HiffyContext::new(hubris, core, subargs.timeout)?;
    if subargs.blackbox {
        return rendmp_blackbox(subargs, hubris, core, &mut context);
    } else if subargs.open_pin {
        return rendmp_open_pin(&subargs, hubris, core, &mut context);
    } else if subargs.phase_check {
        // Bail out early if the arguments are invalid
        let _ = check_addr(&subargs, hubris)?;
        let out = rendmp_phase_check(&subargs, hubris, core, &mut context);
        if let Err(e) =
            restore_default_config(&subargs, hubris, core, &mut context)
                .context("failed to restore default cfg")
        {
            if out.is_err() {
                warn!(
                    "error restoring default cfg when recovering from error: \
                     {e:?}"
                );
            } else {
                return Err(e);
            }
        }
        return out;
    }

    let i2c_read = context.get_function("I2cRead", 7)?;
    let i2c_write = context.get_function("I2cWrite", 8)?;

    let hargs = match (&subargs.dev.rail, &subargs.dev.device) {
        (Some(rail), None) => {
            let mut found = None;

            for device in &hubris.manifest.i2c_devices {
                if let HubrisI2cDeviceClass::Pmbus { rails } = &device.class {
                    for r in rails {
                        if rail == &r.name {
                            found = match found {
                                Some(_) => {
                                    bail!("multiple devices match {}", rail);
                                }
                                None => Some(device),
                            }
                        }
                    }
                }
            }

            match found {
                None => {
                    bail!("rail {} not found", rail);
                }
                Some(device) => I2cArgs::from_device(device),
            }
        }

        (None, None) => {
            bail!("must provide a device as either a rail or an address");
        }

        (_, _) => I2cArgs::parse(
            hubris,
            &subargs.dev.bus,
            subargs.dev.controller,
            &subargs.dev.port,
            &subargs.dev.mux,
            &subargs.dev.device,
        )?,
    };

    let device = if let Some(driver) = &subargs.dev.driver {
        match pmbus::Device::from_str(driver) {
            Some(device) => device,
            None => {
                bail!("unknown device \"{}\"", driver);
            }
        }
    } else if let Some(ref driver) = hargs.device {
        match pmbus::Device::from_str(driver) {
            Some(device) => device,
            None => {
                bail!("{} is not recognized as a PMBus device", driver);
            }
        }
    } else {
        bail!("not recognized as a device");
    };

    let all = all_commands(device);

    let mut base = vec![Op::Push(hargs.controller), Op::Push(hargs.port.index)];

    if let Some(mux) = hargs.mux {
        base.push(Op::Push(mux.0));
        base.push(Op::Push(mux.1));
    } else {
        base.push(Op::PushNone);
        base.push(Op::PushNone);
    }

    let address = match hargs.address {
        Some(address) => address,
        None => {
            bail!("expected device");
        }
    };

    base.push(Op::Push(address));

    let dmaaddr = match all.get("DMAADDR") {
        Some((code, _, write)) => {
            if *write != pmbus::Operation::WriteWord {
                bail!("DMAADDR mismatch: found {:?}", write);
            }
            *code
        }
        _ => {
            bail!("no DMAADDR command found; is this a Renesas device?");
        }
    };

    let dmaseq = match all.get("DMASEQ") {
        Some((code, read, _)) => {
            if *read != pmbus::Operation::ReadWord32 {
                bail!("DMASEQ mismatch: found {:?}", read);
            }
            *code
        }
        _ => {
            bail!("no DMASEQ command found; is this a Renesas device?");
        }
    };

    let word_result = |result: &Result<Vec<u8>, u32>, what| -> Result<u32> {
        match result {
            Err(err) => {
                bail!("failed to read {}: {}", what, i2c_read.strerror(*err));
            }

            Ok(result) => {
                if result.len() != 4 {
                    bail!("bad length on {}: {:x?}", what, result);
                }

                Ok(u32::from_le_bytes(result[0..4].try_into().unwrap()))
            }
        }
    };

    let dmaread_ops = |ops: &mut Vec<Op>, addr: [u8; 2], nbytes: u8| {
        //
        // Push the operations to perform a 4-byte indirect read:  a DMAADDR
        // operation to set the address, and then a 4-byte DMASEQ read
        //
        ops.push(Op::Push(dmaaddr));
        ops.push(Op::Push(addr[0]));
        ops.push(Op::Push(addr[1]));
        ops.push(Op::Push(2));
        ops.push(Op::Call(i2c_write.id));
        ops.push(Op::DropN(4));

        ops.push(Op::Push(dmaseq));
        ops.push(Op::Push(nbytes));
        ops.push(Op::Call(i2c_read.id));
        ops.push(Op::DropN(2));
    };

    if subargs.crc {
        let d = RendmpDevice::from_str(hargs.device.as_ref().unwrap())?;
        let mut ops = base.clone();
        dmaread_ops(&mut ops, d.crc_addr(), 4);

        ops.push(Op::Done);
        let results = context.run(core, ops.as_slice(), None)?;

        let crc = word_result(&results[1], "CRC")?;
        humility::msg!("{d} at {hargs} has CRC 0x{crc:<08x}");

        return Ok(());
    }

    if subargs.slots {
        let d = RendmpDevice::from_str(hargs.device.as_ref().unwrap())?;
        let mut ops = base.clone();

        dmaread_ops(&mut ops, d.slot_addr(), 4);
        dmaread_ops(&mut ops, d.crc_addr(), 4);

        ops.push(Op::Done);
        let results = context.run(core, ops.as_slice(), None)?;

        let nslots = word_result(&results[1], "available slots")?;
        humility::msg!("{d} at {hargs} has {nslots} slots available");

        return Ok(());
    }

    if let Some(ref flash) = subargs.flash {
        let hex = RendmpHex::from_file(flash, address)?;

        //
        // We first need to validate that the IC_DEVICE_ID matches.  The
        // IC_DEVICE_REV is permitted to differ.
        //
        let mut ops = base.clone();

        //
        // Read IC_DEVICE_ID. This is a block read, so the length is None.
        //
        ops.push(Op::Push(pmbus::CommandCode::IC_DEVICE_ID as u8));
        ops.push(Op::PushNone);
        ops.push(Op::Call(i2c_read.id));
        ops.push(Op::DropN(2));

        //
        // Read IC_DEVICE_REV. This too is a block read, so the length is None.
        //
        ops.push(Op::Push(pmbus::CommandCode::IC_DEVICE_REV as u8));
        ops.push(Op::PushNone);
        ops.push(Op::Call(i2c_read.id));
        ops.push(Op::DropN(2));

        //
        // Read the number of slots left and the CRC.
        //
        dmaread_ops(&mut ops, hex.device.slot_addr(), 4);
        dmaread_ops(&mut ops, hex.device.crc_addr(), 4);

        ops.push(Op::Done);
        let results = context.run(core, ops.as_slice(), None)?;

        match &results[0] {
            Err(err) => {
                bail!(
                    "failed to read IC_DEVICE_ID: {}",
                    i2c_read.strerror(*err)
                );
            }

            Ok(result) => {
                if result.len() != 4 {
                    bail!("bad length on IC_DEVICE_ID: {:x?}", result);
                }

                if result[1] != hex.ic_device_id[1] {
                    if let Ok(device) = RendmpDevice::from_id(result[1]) {
                        bail!(
                            "device mismatch: expected {}, found {}",
                            hex.device,
                            device
                        );
                    }
                }

                if result != &hex.ic_device_id[0..4] {
                    bail!(
                        "IC_DEVICE_ID mismatch: expected {:x?} found {:x?}",
                        hex.ic_device_id,
                        result
                    );
                }
            }
        }

        let nslots = word_result(&results[3], "available slots")?;
        humility::msg!("{nslots} NVM slots remain");

        //
        // Check that the number of available slots seems sane -- and (for
        // now, anyway) refuse to operate if we've burned through a bunch of
        // slots.
        //
        if nslots > 28 {
            bail!("number of NVM slots is impossibly high; aborting");
        }

        if nslots < 10 {
            bail!("number of available NVM slots is scarily low; aborting");
        }

        //
        // Check the CRC.  If that matches, we need to be forced to continue.
        //
        let crc = word_result(&results[5], "CRC")?;

        if crc == hex.crc {
            let msg = format!("image CRC (0x{crc:08x}) matches OTP CRC");

            if subargs.check {
                humility::msg!("{msg}");
                return Ok(());
            }

            if !subargs.force {
                bail!("{msg}; use --force to force");
            } else {
                humility::msg!("{msg}; flashing anyway");
            }
        } else if subargs.check {
            bail!(
                "image CRC (0x{:08x}) does not match OTP CRC (0x{:08x})",
                hex.crc,
                crc
            );
        }

        let nbytes = hex.data.iter().fold(0, |n, v| n + v.len());

        if subargs.dryrun {
            humility::msg!("would flash {nbytes} bytes");
            return Ok(());
        }

        humility::msg!("flashing {nbytes} bytes");

        let started = Instant::now();
        let bar = ProgressBar::new(nbytes as u64);

        bar.set_style(
            ProgressStyle::default_bar().template(
                "humility: flashing [{bar:30}] {bytes}/{total_bytes}",
            ),
        );

        let mut start = 0;
        let max = hex.data.len();
        let mut nwritten = 0usize;
        let nwrites = 32;

        //
        // Okay, time to burn!  To keep this simple, we are going to just pass
        // our data in program text -- we aren't optimizing for performance
        // here.
        //
        loop {
            let mut ops = base.clone();

            for i in start..start + nwrites {
                if i < max {
                    let payload = &hex.data[i];
                    let len = payload.len() as u8;

                    for datum in payload {
                        ops.push(Op::Push(*datum));
                    }

                    ops.push(Op::Push(len - 1));
                    ops.push(Op::Call(i2c_write.id));
                    ops.push(Op::DropN(len + 1));
                    nwritten += payload.len();
                }
            }

            ops.push(Op::Done);
            let results = context.run(core, ops.as_slice(), None)?;

            bar.set_position(nwritten as u64);

            for (ndx, r) in results.iter().enumerate() {
                if let Err(err) = r {
                    bail!(
                        "failed to write {:x?}: {}",
                        hex.data[start + ndx],
                        i2c_write.strerror(*err)
                    );
                }
            }

            start += nwrites;

            if start >= max {
                break;
            }
        }

        bar.finish_and_clear();

        humility::msg!(
            "flashed {} in {}",
            HumanBytes(nbytes as u64),
            HumanDuration(started.elapsed())
        );

        let waiting = Instant::now();

        //
        // We are hopefully done!  Now we're going to look for success up
        // to the prescribed two seconds (after which we will fail).
        //
        loop {
            let mut ops = base.clone();

            dmaread_ops(&mut ops, hex.device.programmer_status_addr(), 2);
            dmaread_ops(&mut ops, hex.device.bank_status_addr(), 8);
            ops.push(Op::Done);

            let results = context.run(core, ops.as_slice(), None)?;

            let status = match &results[1] {
                Err(err) => {
                    bail!(
                        "programmer status failed: {}",
                        i2c_read.strerror(*err)
                    );
                }

                Ok(result) => {
                    if result.len() != 2 {
                        bail!("bad length on status: {:x?}", result);
                    }

                    u16::from_le_bytes(result[0..2].try_into().unwrap())
                }
            };

            let banks = match &results[3] {
                Err(err) => {
                    bail!("bank status failed: {}", i2c_read.strerror(*err));
                }

                Ok(result) => hex.device.bank_status(result)?,
            };

            for (ndx, bank) in banks.iter().enumerate() {
                match bank {
                    None => {
                        bail!("banks {:x?}: bank {} invalid", banks, ndx);
                    }
                    Some(ref bank)
                        if *bank != RendmpBankStatus::BankUnaffected =>
                    {
                        humility::msg!("bank {ndx}: {bank}");
                    }
                    _ => {}
                }
            }

            match hex.device.check_programmer_status(status) {
                Ok(_) => break,
                Err(err) => {
                    if waiting.elapsed().as_secs_f32() > 2.0 {
                        return Err(err);
                    }
                }
            }

            thread::sleep(Duration::from_millis(100));
        }

        humility::msg!(
            "flashed successfully after {} ms; power cycle \
             to load new configuration",
            waiting.elapsed().as_millis(),
        );

        return Ok(());
    }

    if subargs.dump {
        let blocksize = 128u8;
        let nblocks = 8;
        let memsize = 256 * 1024usize;
        let laps = memsize / (blocksize as usize * nblocks);
        let mut addr = 0;

        let bar = ProgressBar::new(memsize as u64);

        let mut filename;
        let mut i = 0;

        let filename = loop {
            filename = format!("hubris.rendmp.dump.{}", i);

            if let Ok(_f) = fs::File::open(&filename) {
                i += 1;
                continue;
            }

            break filename;
        };

        let mut file =
            OpenOptions::new().write(true).create_new(true).open(&filename)?;

        humility::msg!("dumping device memory to {filename}");

        bar.set_style(ProgressStyle::default_bar().template(
            "humility: dumping device memory \
                          [{bar:30}] {bytes}/{total_bytes}",
        ));

        for lap in 0..laps {
            let mut ops = base.clone();

            //
            // If this is our first lap through, set our address to be 0
            //
            if lap == 0 {
                ops.push(Op::Push(dmaaddr));
                ops.push(Op::Push(0));
                ops.push(Op::Push(0));
                ops.push(Op::Push(2));
                ops.push(Op::Call(i2c_write.id));
                ops.push(Op::DropN(4));
            }

            ops.push(Op::Push(dmaseq));
            ops.push(Op::Push(blocksize));

            //
            // Unspeakably lazy, but also much less complicated:  we just
            // unroll our loop here.
            //
            for _ in 0..nblocks {
                ops.push(Op::Call(i2c_read.id));
            }

            //
            // Kick it off
            //
            ops.push(Op::Done);

            let results = context.run(core, ops.as_slice(), None)?;

            let start = if lap == 0 {
                match results[0] {
                    Err(err) => {
                        bail!(
                            "failed to set address: {}",
                            i2c_write.strerror(err)
                        )
                    }
                    Ok(_) => 1,
                }
            } else {
                0
            };

            for result in &results[start..] {
                match result {
                    Ok(val) => {
                        file.write_all(val)?;
                        addr += val.len();
                        bar.set_position(addr as u64);
                    }
                    Err(err) => {
                        bail!("{:?}", err);
                    }
                }
            }
        }
    }

    Ok(())
}

pub fn init() -> Command {
    Command {
        app: RendmpArgs::command(),
        name: "rendmp",
        run: rendmp,
        kind: CommandKind::Attached {
            archive: Archive::Required,
            attach: Attach::LiveOnly,
            validate: Validate::Booted,
        },
    }
}
