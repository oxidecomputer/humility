// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

use anyhow::{bail, Context, Result};
use clap::Parser;
use std::collections::BTreeMap;
use std::fs::File;
use std::io::Write;

#[derive(Debug, Parser)]
#[clap(max_term_width = 80, about = "extra tasks to help you work on Hubris")]
enum Xtask {
    /// Compiles readme
    Readme,
}

fn make_readme() -> Result<()> {
    use cargo_metadata::MetadataCommand;
    let mut cmds = BTreeMap::new();

    let metadata =
        MetadataCommand::new().manifest_path("./Cargo.toml").exec().unwrap();

    for id in &metadata.workspace_members {
        let package =
            metadata.packages.iter().find(|p| &p.id == id).unwrap().clone();

        if let Some(cmd) = package.name.strip_prefix("humility-cmd-") {
            let description = match package.description {
                Some(description) => description,
                None => {
                    bail!("{cmd} is missing \"description\" in manifest");
                }
            };

            cmds.insert(cmd.to_string(), (description, package.manifest_path));
        }
    }

    let root = metadata.workspace_root;
    let input = std::fs::read(root.join("README.md.in"))?;
    let mut output = File::create(root.join("README.md"))?;

    writeln!(
        output,
        r##"<!--
  -- DO NOT EDIT THIS FILE DIRECTLY!
  --
  -- This file is made by running "cargo xtask readme", which pulls in
  -- README.md.in and then automatically concatenates documentation for
  -- each command.  The documentation for the commands is generated by
  -- "cargo readme" in each command crate, and the documentation itself
  -- is written in rustdoc in those crates.
  -->
"##
    )?;

    output.write_all(&input)?;

    writeln!(output, "## Commands\n")?;

    for (cmd, (description, _)) in &cmds {
        writeln!(output, "- [humility {cmd}](#humility-{cmd}): {description}",)?;
    }

    for (cmd, (_, path)) in &cmds {
        let cmd_path = path.parent().unwrap();
        let mut lib_path = cmd_path.join("src");
        lib_path.push("lib.rs");
        let mut file = std::fs::File::open(&lib_path).with_context(|| {
            format!("failed to open {}", lib_path.display())
        })?;
        let contents = cargo_readme::generate_readme(
            cmd_path, &mut file, None, false, true, true, true,
        )
        .map_err(|error| {
            anyhow::anyhow!("failed to generate README for {cmd}: {error}")
        })?;

        //
        // We are prescriptive about what we expect this output to look like.
        //

        let header = format!("### `humility {cmd}`\n");
        if !contents.starts_with(&header) {
            bail!(
                "documentation for {cmd} is malformed: \
                must begin with '{header}'",
            );
        }

        output.write_all(contents.as_bytes())?;
        writeln!(output, "\n\n")?;
    }

    Ok(())
}

fn main() -> Result<()> {
    let xtask = Xtask::parse();

    match xtask {
        Xtask::Readme => {
            make_readme()?;
        }
    }

    Ok(())
}
